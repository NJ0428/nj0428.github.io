---
layout: single
title: "리눅스 프로세스(Process) 정리 – 개념, 유형, PID, 좀비 프로세스"
categories: Linux
author_profile: false
toc: true
---

리눅스 운영체제에서 **프로세스(Process)**는 실행 중인 프로그램을 의미하며, **시스템 자원 관리의 핵심 단위**입니다. 이 글에서는 프로세스의 개념부터 라이프 사이클, 유형, 그리고 PID 관리까지 **운영체제 관점에서 꼭 알아야 할 핵심 정보**를 정리했습니다.

------

## 1. 프로세스란?

### 정의

- **프로세스(Process)**는 **메모리에 적재되어 실행 중인 프로그램 인스턴스**입니다.
- 디스크에 있는 실행 파일이 실행되면서 독립된 주소 공간과 자원(PID, 메모리, 파일 등)을 갖게 됩니다.

> 프로그램 ≠ 프로세스
>
> 하나의 프로그램 → 여러 프로세스로 실행 가능

------

## 2. 프로세스의 주요 특징

### 2.1 라이프 사이클

| 상태             | 설명                                   |
| ---------------- | -------------------------------------- |
| 생성(Create)     | `fork()` 또는 `exec()` 호출로 생성됨   |
| 실행(Running)    | CPU에서 실제 실행 중인 상태            |
| 대기(Waiting)    | I/O 완료 또는 이벤트 대기 중           |
| 중지(Stopped)    | 일시 정지 상태 (예: `Ctrl + Z`)        |
| 좀비(Zombie)     | 종료되었으나 아직 부모가 수거하지 않음 |
| 종료(Terminated) | 완전히 종료됨 (부모가 wait 호출 시)    |

------

### 2.2 고유 PID와 PPID

- **PID**: Process ID (각 프로세스는 고유 식별자 보유)
- **PPID**: Parent Process ID (부모 프로세스 ID)

### 2.3 리소스 정보

- 메모리, CPU 시간, 열린 파일 핸들, 우선순위 등
- `top`, `ps aux`, `htop` 명령어로 확인 가능

------

## 3. 프로세스의 유형

### 3.1 최상위 프로세스 (PID 1)

| 시스템        | 최상위 프로세스 | 설명                                                    |
| ------------- | --------------- | ------------------------------------------------------- |
| CentOS 6 이하 | `init`          | `/sbin/init` – SysVinit 기반                            |
| CentOS 7 이상 | `systemd`       | `/usr/lib/systemd/systemd` – 병렬 초기화 및 서비스 관리 |

### systemd의 특징

- **On-demand** 실행: 필요한 시점에 서비스 시작
- **병렬 처리**로 부팅 속도 향상
- 유닛 단위 서비스 관리: `systemctl` 명령으로 제어

------

### 3.2 부모 프로세스와 자식 프로세스

- **부모 프로세스**: 자식 프로세스를 생성하는 주체

  → PPID로 추적 가능

- **자식 프로세스**: `fork()` 또는 `exec()`로 생성됨

  → PID 부여

### 확인 명령어

```bash
ps -ef | grep [프로세스명]
```

------

### 3.3 고아 프로세스 (Orphan Process)

- **정의**: 부모 프로세스가 비정상 종료되어 **부모가 없는 자식 프로세스**
- **처리 방식**: `init` 또는 `systemd`가 **고아 프로세스를 수용하여 관리**

> 고아 프로세스는 자동 종료되지 않으며, 정상적으로 시스템이 관리합니다.

------

### 3.4 좀비 프로세스 (Zombie Process)

- **정의**: 자식 프로세스가 종료되었으나, 부모 프로세스가 종료 상태를 `wait()`로 수집하지 않아 **프로세스 테이블에 PID가 남아 있는 상태**
- 특징:
  - 리소스는 해제됨
  - **PID가 남아 있음**
  - 프로세스 수가 많아지면 시스템에 **자원 낭비 및 부하 유발**

### 확인 명령어

```bash
ps aux | grep Z
```

### 해결 방법

- 부모 프로세스를 재시작하거나 kill (좀비는 직접 종료 불가)
- 필요 시 `kill -9 PPID` 후 systemd가 orphan 처리

------

## 실습 예제

### 프로세스 확인

```bash
ps -ef | less
top
```

### 특정 프로세스의 PID 확인

```bash
pidof nginx
```

### 프로세스 상태 확인

```bash
ps -o pid,ppid,state,comm -C sshd
```

------

## 질문 정리

### Q1. PID는 중복될 수 있나요?

- 시스템 재시작 전에는 중복되지 않지만, **종료 후 재사용 가능**합니다.

------

### Q2. 좀비 프로세스가 왜 위험한가요?

- **프로세스 테이블(PID slot)을 차지**하기 때문입니다. 일정 수를 초과하면 새로운 프로세스 생성이 불가능해집니다.

------

### Q3. PID 1이 죽으면 어떻게 되나요?

- `init` 또는 `systemd`는 **시스템의 근간**이므로, 죽으면 시스템 전체가 종료될 수 있습니다.

------

### Q4. 사용자 프로그램이 항상 프로세스인가요?

- 실행된 순간부터 **프로세스(메모리에 존재하는 실행 단위)**로 작동합니다.

------

### Q5. 자식 프로세스를 수거하지 않으면?

- 좀비 프로세스가 생성되며, 부모 종료 시 `init`이 수거합니다.

------

**정리**

| 유형          | PID                    | 설명                             |
| ------------- | ---------------------- | -------------------------------- |
| init/systemd  | 1                      | 시스템 최상위 프로세스           |
| 일반 프로세스 | 고유 PID               | 실행 중인 사용자/시스템 프로세스 |
| 고아 프로세스 | 부모 없음              | systemd가 대신 관리              |
| 좀비 프로세스 | 종료됨 + 테이블에 남음 | 부모가 수거하지 않은 자식        |

리눅스의 프로세스 구조는 **시스템 자원 관리와 안정성의 핵심 요소**입니다. 실무에서는 `ps`, `top`, `kill`, `systemctl` 명령어를 적절히 사용해 **프로세스 상태를 모니터링하고 제어**할 수 있어야 합니다.
