---
layout: single
title: "자바 배열(Array) 선언·초기화부터 고급 활용"
categories: Java
author_profile: false
toc: true
---

자바 **배열(Array)**﻿은 *같은 자료형* 데이터를 **연속적**으로 저장해 고속으로 접근할 수 있는 기본 자료구조입니다. 크기가 고정되기 때문에 메모리 활용이 뛰어나고, 캐시 적중률이 높아 **성능**을 중시하는 코드에 적합합니다.

------

## 배열 기본 사용법

### 배열 선언·생성·초기화

```java
int[] scores;              // 권장 선언 방식
scores = new int[5];       // 길이 5로 생성
int[] ages = {21, 24, 19}; // 선언과 동시에 초기화
```

- **배열 선언**: `타입[] 변수명` 형태를 권장합니다.
- **생성**: `new 타입[길이]` — 길이는 음수가 될 수 없으며 **고정**됩니다.
- **초기화**: 중괄호 `{}` 로 값을 나열하면 자동으로 크기가 결정됩니다.

### 요소 접근 및 길이 확인

```java
ages[0] = 25;                    // 값 변경
System.out.println(ages[0]);     // 첫 요소 출력
System.out.println(ages.length); // 배열 크기
```

인덱스는 **0부터 시작**하며, 범위를 벗어나면 `ArrayIndexOutOfBoundsException`이 발생합니다.

------

## 메모리 구조와 성능 특성

| 구분          | 저장 위치   | 특징                      |
| ------------- | ----------- | ------------------------- |
| **배열 객체** | 힙(Heap)    | 연속 메모리 할당, GC 관리 |
| **참조 변수** | 스택(Stack) | 힙 주소 보관              |

- **연속적 배치** 덕분에 **O(1)** 시간으로 인덱스 접근 가능 → 빠른 읽기·쓰기
- 크기가 변하지 않아 *배열 삽입/삭제* 시 **O(n)** 비용이 발생합니다.

------

## 배열의 장점과 한계

**장점**

- **빠른 접근** – 인덱스로 직접 참조
- **메모리 효율** – 캐시 친화적 구조

**단점**

- **크기 고정** – 실행 중 확장·축소 불가
- **삽입/삭제 비용** – 데이터 이동 필요

------

## 고급 배열 활용 테크닉

### 1. 다차원·가변 배열

```java
// 2차원 배열(정방형)
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6}
};

// 비정형(가변) 배열
int[][] jagged = new int[3][];
jagged[0] = new int[2];
jagged[1] = new int[4];
jagged[2] = new int[1];
```

### 2. 배열 복사

```java
System.arraycopy(src, 0, dest, 0, src.length);
int[] copy = Arrays.copyOf(src, 10); // 길이 증가
```

### 3. 정렬·검색·집계

```java
int[] nums = {5, 2, 8, 1};
Arrays.sort(nums);                 // 오름차순
int idx = Arrays.binarySearch(nums, 5);

int sum = Arrays.stream(nums).sum(); // 스트림 합계
```

### 4. 배열 ↔ 컬렉션 변환

```java
String[] names = {"Kim", "Lee"};
List<String> list = Arrays.asList(names);  // 고정 크기 List
```

------

## 배열과 컬렉션 선택 기준

| 상황                                   | 추천 자료구조         |
| -------------------------------------- | --------------------- |
| **크기가 고정**이고 인덱스 접근이 많음 | `배열`                |
| 크기가 변동되고 삽입·삭제가 빈번함     | `ArrayList`           |
| 대용량 데이터에 대한 큐/스택 패턴      | `LinkedList`, `Deque` |

> TIP: 대량 데이터 처리에서 배열 → 스트림 파이프라인으로 넘어가면 병렬 처리 (Arrays.parallelSort, parallelStream())를 간편히 적용할 수 있습니다.

------

## 질문 정리

1. **배열과 ArrayList 중 어떤 것을 써야 하나요?**

   데이터 길이가 *변하지 않고* 성능이 중요하면 **배열**, 그렇지 않으면 **ArrayList**가 유연합니다.

2. **배열을 동적으로 늘릴 수 없나요?**

   직접은 불가합니다. 대신 `Arrays.copyOf()`로 새 배열을 만들어 대체합니다.

3. **배열 정렬 시 가장 빠른 방법은?**

   `Arrays.sort()`는 *Dual-Pivot QuickSort* 기반으로 대부분의 상황에서 충분히 빠르며, JDK 8+에서는 `parallelSort()`로 대용량 배열을 병렬 정렬할 수 있습니다.

4. **가변 배열(jagged array)을 언제 사용하나요?**

   행마다 열의 길이가 다른 **비정형 데이터**(예: 삼각형 행렬)를 메모리 효율적으로 표현할 때 유리합니다.

5. **기본형 배열과 래퍼 배열의 차이점은?**

   `int[]`는 기본형을 직접 저장해 **오토박싱 오버헤드**가 없고, `Integer[]`는 객체 레퍼런스를 담아 **메모리 사용량과 GC 부담**이 증가합니다.
